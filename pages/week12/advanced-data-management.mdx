import { Callout, Steps } from "nextra-theme-docs";

# Advanced Data Management

## Relational Databases

Relational databases have been the backbone of data storage for many years. They store data in a structured format, using tables with rows and columns. Each row represents a unique record, and each column represents a field of that record. This structure allows for efficient storage and retrieval of data and supports complex operations, like joining data from multiple tables.

Relational databases use Structured Query Language (SQL) to interact with the data. SQL is a powerful language that can perform a variety of operations, including creating, reading, updating, and deleting records (known as CRUD operations).

Because CRUD operations are so common, many web frameworks provide an Object Relational Mapping (ORM) layer that abstracts the database interactions. This allows developers to interact with the database using objects and methods, rather than writing SQL queries directly.

This course will not go into the details of relational databases. We'll leave that for your database courses. Instead, we'll focus on how to use relational databases in your applications.

### Serverless Relational Databases

Serverless databases are a relatively new concept. They are fully managed databases that scale automatically and charge based on usage. This means you don't have to worry about provisioning servers, configuring backups, or scaling your database. You simply create a database and start using it. Some common serverless relational databases include:

- [PlanetScale](https://planetscale.com/)
- [Supabase](https://supabase.com/)
- [Vercel Postgres](https://vercel.com/docs/databases/vercel-postgres)
- [Microsoft Azure SQL](https://azure.microsoft.com/en-us/products/azure-sql/database/)
- [Google Cloud SQL](https://cloud.google.com/sql)

### PlanetScale MySQL

PlanetScale MySQL is a serverless relational database that is fully managed by PlanetScale. It is based on MySQL, which is one of the most popular open source relational databases. PlanetScale MySQL is a good choice for students because it is free to use for up to 1B row reads/month, 10M row writes/month, and 5 GB of storage. It also supports unlimited tables, unlimited queries, and unlimited users. (Vercel Postgres is also free but it very limited.)

#### Getting Started with PlanetScale MySQL

Use this quickstart guide to get started with PlanetScale MySQL.

[https://planetscale.com/docs/tutorials/planetscale-quick-start-guide](https://planetscale.com/docs/tutorials/planetscale-quick-start-guide)

#### Using SQL with PlanetScale MySQL

PlanetScale MySQL uses the MySQL protocol, so you can use any MySQL client to connect to it.

The first step is setting up the `.env.local` file with the database credentials. You can find these credentials in the PlanetScale dashboard.

```bash
DATABASE_HOST=aws.connect.psdb.cloud
DATABASE_USERNAME=xxxxxxxxxxxxxxxx
DATABASE_PASSWORD=************
```

Next, you'll need to install the PlanetScale database library. This library provides a wrapper around the MySQL client that handles the connection and authentication for you.

```shell
npm install @planetscale/database
```

Finally, you can use the library to connect to the database and run queries.

```ts
import { connect } from "@planetscale/database";

const config = {
  host: process.env.DATABASE_HOST,
  username: process.env.DATABASE_USERNAME,
  password: process.env.DATABASE_PASSWORD,
};

async function getUsers() {
  const conn = connect(config);
  const { rows } = await conn.execute("SELECT * FROM users;");
  return rows;
}
```

In the example above, we're using the `@planetscale/database` library to connect to the database and run a query. The `connect` function takes a configuration object with the database credentials. It returns a connection object that can be used to run queries.

The `execute` method takes a SQL query and returns an object with the results. The results object contains information about the query, including the number of rows affected, the insert ID, and the time it took to run the query. It also contains the rows returned by the query.

```json
{
  "headers": ["id", "email", "name", "age", "role"],
  "types": {
    "id": "INT32",
    "email": "VARCHAR",
    "name": "VARCHAR",
    "age": "INT32",
    "role": "VARCHAR"
  },
  "fields": [
    {
      "name": "id",
      "type": "INT32",
      "table": "users",
      "orgTable": "users",
      "database": "webdev2-demo",
      "orgName": "id",
      "columnLength": 11,
      "charset": 63,
      "flags": 49667
    },
    ... more fields ...
  ],
  "rows": [
    {
      "id": 1,
      "email": "cprg352+abe@gmail.com",
      "name": "Abe",
      "age": 20,
      "role": "admin"
    }
  ],
  "rowsAffected": 0,
  "insertId": "0",
  "size": 1,
  "statement": "SELECT * FROM users;",
  "time": 4.839211000000001
}
```

## Object Relational Mapping (ORM)

Object-Relational Mapping, more commonly known as ORM, is a programming technique that allows developers to interact with their database like they would with SQL. However, instead of writing SQL queries or stored procedures, with ORM, you directly use your programming language of choice.

The ORM software will convert these lines of code into SQL and send it to the database to perform the requested operation. This allows developers to think and program in their language of choice, thus abstracting away the SQL language.

### Understanding ORM

ORM translates the database's tabular data into a format more fitting with the language you're working with. For instance, in JavaScript, a row in a database table can be represented as an object, where each attribute of the object corresponds to a column of the table.

Object models are used to represent the data in the database. These models are then used to perform CRUD operations on the database. For instance, to represent a user in the database, you would create a user object with the following attributes:

```js
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  age       Int
  role      Role     @default(USER)
}
```

Then, to create a new user in the database, you would write something like this:

```js
const createdUser = await prisma.user.create({
  data: userObject,
});
```

The ORM software will convert this code into SQL and send it to the database to create a new user. The ORM software will also convert the result of the query into a JavaScript object and return it to the caller.

### Advantages of ORM

ORM comes with several advantages:

- Abstraction of SQL: With ORM, you don't need to write SQL code. The ORM system takes care of this. This can lead to faster development and less room for SQL syntax errors.
- Database Agnostic: ORMs allow you to switch between different types of SQL databases (MySQL, SQLite, PostgreSQL, etc.) with minimal code changes.
- Maintainability: Since the database operations are written in the same language as the rest of your code, it's easier to maintain and understand.
- Use of Language Features: ORM lets you utilize the full power of your programming language to manipulate data, including functions, data types, loops, and more.
- Advanced features: Many ORMs come with additional features like caching, transactions, and more.

### Prisma

Prisma is an open-source ORM for Node.js and TypeScript. It supports various databases including PostgreSQL, MySQL, SQLite, and SQL Server. One of the key benefits of Prisma is its focus on type safety and the ability to auto-generate a client based on your database schema, thus reducing a lot of boilerplate and potential for human error.

Read more about Prisma here: https://www.prisma.io/docs/concepts/overview/what-is-prisma

Here are a few steps to help you get started with Prisma.

<Steps>

### Install the Prisma CLI

The Prisma CLI is a command-line interface that allows you to interact with Prisma. To install it, run the following command:

```shell
npm install prisma -D
```

### Initialize Prisma

Next, you need to initialize Prisma in your project. This will create a new prisma directory in your project root with a schema.prisma file. Run the following command:

```shell
npx prisma init
```

### Configure your database

Open the prisma/schema.prisma file and update the datasource db block to point to your own database. Here's an example using MySQL on PlanetScale:

```prisma
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  relationMode = "prisma"
}
```

Next, define the DATABASE_URL in the .env file in your project root:

```env
DATABASE_URL="mysql://user:password@localhost:3306/mydb?schema=public"
```

### Define your data model

In the prisma/schema.prisma file, you can define your data model. Here's an example:

```prisma
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model User {
  id    Int      @id @default(autoincrement())
  email String   @unique
  name  String?
  posts Post[]
}
```

In this example, we have two models: `Post` and `User`. The `Post` model has fields for `id`, `title`, `content`, `published`, `author`, and `authorId`. The `User` model has fields for `id`, `email`, `name`, and `posts`. The `author` field on the `Post` model is a relation to the `User` model. This is known as a _one-to-many_ relationship. A user can have many posts, but a post can only have one user.

### Generate Prisma Client

Prisma Client is an auto-generated database client that enables type-safe database access and reduces boilerplate. You can generate it using the following command:

```shell
npx prisma generate
```

### Push your schema to the database

Normally, you can push your schema to the database using the following command:

```shell
npx prisma db push
```

However, because the command relies on the environment file being called `.env`, you'll need to install the dotenv package and then run the command like this:

```shell
npm install dotenv
npx dotenv -e .env.local prisma db push
```

</Steps>

### Prisma and PlanetScale

The following YouTube playlist shows how to use Prisma with PlanetScale MySQL.

https://www.youtube.com/playlist?list=PLlRapu2ErjJ9DGsGHRwhRlm1FJVSN3FK7

## 🌐 Real-World Example

Let return to the Iotawise project and see how PlanetScale MySQL and Prisma were used to build the backend. We will continue to focus on the _activities_.

### `schema.prisma`

The `schema.prisma` file defines the database schema. It contains a list of models, each with a list of fields. The fields are mapped to columns in the database table.

```prisma
model Activity {
  id          String   @id @default(cuid())
  userId      String   @map(name: "user_id")
  name        String
  description String?
  colorCode   String   @map(name: "color_code")
  createdAt   DateTime @default(now()) @map(name: "created_at")
  updatedAt   DateTime @updatedAt @map(name: "updated_at")

  user User @relation(fields: [userId], references: [id])

  activityLogs ActivityLog[]

  @@map(name: "activities")
}
```

In the example above, we have an `Activity` model with fields for `id`, `userId`, `name`, `description`, `colorCode`, `createdAt`, and `updatedAt`. The `id` field is marked as the primary key with the `@id` attribute. The `userId` field is mapped (as a foreign key) to the `user_id` column in the database table.

Because of the `@relation` attribute, Prisma will automatically create a `user` field on the `Activity` model. This field will contain the `User` object associated with the activity. This is known as a _one-to-many_ relationship. An activity can only have one user, but a user can have many activities. Given an activity, you can get the user by accessing the `user` field.

### CRUD Operations

Prisma provides a set of methods for performing CRUD operations on the database. These methods are automatically generated based on the database schema.

#### Create

In `/api/activities/route.ts`, we have the following code in the `POST` function to create a new activity.

```ts
const activity = await db.activity.create({
  data: {
    name: body.name,
    description: body.description,
    colorCode: body.colorCode,
    userId: session.user.id,
  },
  select: {
    id: true,
  },
});
```

The `activity.create` method takes an object with the data to insert into the database. It returns an object with the newly created activity. The `select` attribute tells Prisma which fields to return. In this case, we only want the `id` field.

#### Read

In `/api/activities/route.ts`, we have the following code in the `GET` function to get a list of activities.

```ts
// Get all of current user's activities
const activities = await db.activity.findMany({
  select: {
    id: true,
    name: true,
    description: true,
    colorCode: true,
    createdAt: true,
  },
  where: {
    userId: session.user.id,
  },
});
```

In this code, we're using the `activity.findMany` method to get a list of activities. The `select` attribute tells Prisma which fields to return. In this case, we want all of the fields except for `updatedAt`. The `where` attribute tells Prisma to only return activities where the `userId` matches the current user's ID.

### Update

In `/api/activities/[activityId]/route.ts`, we have the following code in the `PATCH` function to update an activity.

```ts
// Update the activity
await db.activity.update({
  where: {
    id: params.activityId,
  },
  data: {
    name: body.name,
    description: body.description,
    colorCode: body.colorCode,
    updatedAt: new Date(),
  },
});
```

In this code, we're using the `activity.update` method to update an activity. The `where` attribute tells Prisma which activity to update. The `data` attribute tells Prisma which fields to update.

### Delete

In `/api/activities/[activityId]/route.ts`, we have the following code in the `DELETE` function to delete an activity.

```ts
// Delete the activity
await db.activity.delete({
  where: {
    id: params.activityId as string,
  },
});
```

In this code, we're using the `activity.delete` method to delete an activity. The `where` attribute tells Prisma which activity to delete. In this case, we're using the `activityId` from the URL, and `as string` to tell TypeScript that it's a string.

## 📖 Further Reading

- [PlanetScale ](https://planetscale.com/docs/concepts/what-is-planetscale)
- [Prisma](https://www.prisma.io/)
